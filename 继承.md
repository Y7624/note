##	继承

***封装：对象代表什么，就得封装对应的数据，并提供数据对应的行为***

**java中提供了一个关键字extends，我们可以让一个类和另一个类建立起继承关系。**

**student称为子类(派生类),person称为父类(基类和超类)**

**可以把多个子类重复的代码抽取到父类中，提高代码的复用性。**

**子类可以在父类的基础上，增加其他功能，使子类更强大。**

**当类与类之间，存在相同（共性）的内容，并满足子类是父类的一种，就可以考虑使用继承****，**来优化代码****

**子类可以得到父类的属性和行为，子类可以使用**	

**子类可以在父类的基础上1新增其他功能，子类更加强大**	

**java中只支持单继承，不支持多继承，但支持多层继承**	

 **类跟类之间的父子关系**

**重复的东西写在父类里面**

public class 子类 extends 父类{}

#### 继承的特点：

**单继承：一个子类只能继承一个父类**

**不支持多继承：子类不能同时继承多个父类**

**多层继承：子类A继承父类B，父类B可以继承父类C**

**每一个类都直接或者间接的继承与object**

**子类只能访问父类中非私有的成员**

***

#### 子类到底能继承父类中的哪些内容？

**关于成员变量，子类都可以继承下来**

**父类的构造方法不能被子类继承**

**不管是私有的还是非私有的，子类都可以继承父类的成员变量**

**但是私有的成员变量子类不能直接使用**

#### 继承的内存图

**虚方法表:非static修饰的，非final修饰的,非private修饰的**

**只有父类中的虚方法才能被子类继承**

**成员方法：虚方法表能，否则不能**

***

#### 继承中的构造方法

**父类中的构造方法不会被子类继承**

**子类中所有的构造方法默认先访问父类中的无参构造，再执行自己**

**子类在初始化的时候，有可能会使用到父类中的数据，如果数据没有初始化完成，子类将无法使用父类的数据**

**子类初始化之前，一定要调用父类构造方法完成父类数据空间的初始化。**

**子类构造方法的第一行语句默认都是：super（),不写也存在，且必须写在第一行**

**如果想调用父类有参构造，必须手动写super进行调用。**

**默认先访问几曾父类的构造方法，但是可以通过super调用。**

**子类构造方法的第一行，有一个默认的super()；**

**this、super使用总结**

**this：理解为一个变量，表示当前方法调用者的地址值**

**super:代表父类存储空间**

**super.成员变量:访问父类成员变量**

**super.成员方法(…):访问父类成员变量**

**super(…)访问父类构造方法**

**this.成员变量：访问本类成员变量**

**this.成员方法(…):访问本类成员方法**

**this(…)：访问本类构造方法**

```
package excirse;

public class LecturerTest {
    public static void main(String[] args) {
        // 测试有参构造方法
        Lecturer le = new Lecturer(1, "小黄", "教学");
        System.out.println(le.getNum() + ", " + le.getName() + ", " + le.getWork());
        le.work(); // 应输出 "上课讲授内容"

        // 测试无参构造方法 + Setter
        Lecturer l = new Lecturer();
        l.setNum(6);
        l.setName("晓燕");
        l.setWork("讲师");
        System.out.println(l.getNum() + ", " + l.getName() + ", " + l.getWork());
        l.work(); // 应输出 "上课讲授内容"
    }
}
```

```
package excirse;

public class Employee {
    //1.类名见名知意
    //2.所有的成员变量都需要私有
    //3.构造方法(空参 带全部参数的构造）
    //4.get/set
    private int num;
    private String name;
    private String work;

    //空参构造
    public Employee(){
        System.out.println("这是一个空参构造");
    }
    public Employee(int num,String name,String work){
        this.num=num;
        this.name=name;
        this.work=work;

    }

    public int getNum() {
        return num;
    }

    public void setNum(int num) {
        this.num = num;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getWork() {
        return work;
    }

    public void setWork(String work) {
        this.work = work;
    }
    //工作
    public void work(){
        System.out.println("这是员工的工作");
    }
    //生活
    public void life(){
        System.out.println("员工都是为了生活");
    }
}
```

### 成员变量和成员方法的访问特点



**继承中：成员变量的访问特点：就近原则，谁离我近，我就用谁**

**先在局部位置找，本类伪装找，父类成员位置找，父类成员位置找，逐级往上**

**this是到本类成员变量中找**

**继承中：成员方法的访问特点：**

**直接调用满足就近原则：谁离我近，我就用谁，super调用，直接访问父类**

**方法的重写：当父类的方法不能满足子类现在的需求时，需要进行方法重写**

**书写格式：在继承体系中，子类出现了和父类中一模一样的方法声明，我们就称子类这个方法是重写的方法**

**@override重写注解**

**发生了重写，就会覆盖**

**子类覆盖了从父类里面继承下来的虚方法表里面的方法**

**子类重写父类方法时，访问权限子类必须大于等于父类**

**子类重写父类方法时，返回值类型子类必须小于等于父类**

***重写的方法尽量与父类保持一致***

***只有被添加到虚方法表中的方法才能被重写***

```
package a05oopentenddemo5;

public class Test {
    public static void main(String[] args) {
        Student s = new Student();
        s.lunch();

        // 测试海外学生
        OverseasStudent os = new OverseasStudent();
        os.lunch();
    }
}

class Person {
    public void eat() {
        System.out.println("吃饭");
        // 修正：void方法不能返回null
    }

    public void drink() {
        System.out.println("喝开水");
    }
}

class OverseasStudent extends Person { // 类名首字母大写
    @Override
    public void eat() {  // 修正：保持返回类型一致（void）
        System.out.println("吃意大利面");
    }

    @Override
    public void drink() {
        System.out.println("喝冰水");
    }

    public void lunch() {
        System.out.println("=== 海外学生午餐 ===");
        this.eat();    // 调用重写后的方法
        this.drink();

        super.eat();   // 调用父类原始方法
        super.drink();
    }
}

class Student extends Person {
    // 建议添加实际的方法重写
    @Override
    public void eat() {
        System.out.println("学生在食堂吃饭");
    }

    @Override
    public void drink() {
        System.out.println("学生喝矿泉水");
    }

    public void lunch() {
        System.out.println("\n=== 普通学生午餐 ===");
        System.out.println("通过this调用：");
        this.eat();    // 调用重写后的方法
        this.drink();

        System.out.println("通过super调用：");
        super.eat();   // 强制调用父类方法
        super.drink();
    }
}
```

**多态的优势：在多态形式下，右边对象可以实现解耦合，便于扩展和维护**

**定义方法的时候，使用父类型作为参数，可以接近所有子类对象，体现多态的扩展性和便利**
