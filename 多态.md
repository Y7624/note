## 多态

**有了封装才有面向对象，有了面向对象才有继承和多态**

**没有继承就没有多态**

**多态的应用场景**

**多态可以根据传递对象的不同，调用不同的show方法**

**对象的多种形态**，   **多种形态，同类型的对象，表现出不同形态**

**多态的表现形式：父类类型  对象名称=子类对象；**

**多态的前提：有继承/实现关系；**  **有父类引用指向子类对象**  ，**有方法重写**

**多态的好处，使用父类型作为参数，可以接收所有子类对象**

**体现多态的扩展性和便利**

#### 多态调用成员的特点

**变量调用：编译看左边，运行也看左边**

**方法调用：编译看左边，运行看右边**

多态方式创建对象

***fu f=new zi;***

```
package a02oopolymorphismdemo2;

public class test {
    public static void main(String[] args) {
    //创建对象（多态方式）
    //  Fu f=new Zi
    Animal a=new dog();
    //调用成员变量，编译看左边，运行也看左边
    //编译看左边：javac编译代码的时候，会看左边父类中有没有这个变量，如果有，编译成功，如果没有，编译失败
    //运行也看左边：java运行的时候，实际获取的就是左边父类中成员变量的值
        System.out.println(a.name);

        //调用成员方法
        //编译看左边：javac编译代码的时候，会看左边的父类中有没有这个方法，如果有，编译成功，没有编译失败
        //运行看右边：java运行代码的时候，实际上运行的是子类中的方法
        a.show();

        //成员变量：在子类的对象中，会把父类的成员变量继承下来
        //成员方法：如果子类对方法进行了重写，那么在虚方法表中会把父类的方法进行重写
    }
}

        class Animal{
            String name="动物";

            public void show(){
                System.out.println("动物的show方法");
            }
        }
        class dog extends Animal{
            String name="狗";

            @Override
            public void show() {
                System.out.println("dog的show方法");
            }
        }
        class cat extends  Animal{
            String name="小猫";

            @Override
            public void show() {
                System.out.println("cat的show方法");
            }
        }
```

**调用成员方法时：编译看左边，运行看右边**