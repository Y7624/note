###   泛型

**定义类、接口、方法时，同时声明了一个或者多个类型变量，如<E>**

**称为泛型类、泛型接口、泛型方法、它们统称为泛型**

**泛型提供了在编译阶段约束能操作的数据类型，并自动进行检查的能力**

**这样可以避免强制类型转换，及其可能出现的异常**

**泛型的格式：<数据类型>**

**泛型只能支持引用数据类型**

```
import java.util.ArrayList;
import java.util.Iterator;

public class genericsdemo1 {
    public static void main(String[] args) {
        //没有泛型的时候，集合如何存储数据
        //结论：如果我们没有给集合指定类型，默认认为所有的数据都是object;;
        //此时可以往集合里面添加任意的数据类型
        //带来一个坏处，我们获取数据的时候，无法使用他的特有行为

        //此时推出了泛型，可以在添加数据的时候进行统一
        //而且我们在获取数据的时候，也省得强转了，非常方便
        //1.创建集合的对象
        ArrayList<String> list=new ArrayList<>();

        //2.添加数据
        //list.add(123);
        list.add("aaa");
        //list.add(new Student("zhangsan",123));

        //遍历集合获取里面的每一个元素
        Iterator<String> it=list.iterator();
        while(it.hasNext()){
           String str=it.next();
            //多态的弊端不能访问子类的特有功能
            str.length();
            System.out.println(str);
        };
    }
}
```

**泛型的好处：统一的数据类型**

**把运行时期的问题提取到了编译期间，避免了强制类型转换可能出现的异常，因为在编译阶段类型就能确定下来**

**泛型的擦除**

**泛型就是为了统一集合的类型**

***泛型中不能写基本数据类型***

**指定泛型的具体类型后，传递数据，可以传入该类类型或者子类类型**

**如果不写泛型，类型默认是object**

###   定义泛型

**类后面—>泛型类**

**方法上面—>泛型方法**

**借口后面—>泛型接口**

**泛型类：当一个类中，某个变量的数据类型不稳定时，就可以定义带泛型的类**

*格式：修饰符 class 类名<>{*

*}*

**泛型方法：**

**方法中形参类型不确定时，可以使用类后面定义的泛型[E]**

*方法中形参类型不确定时：*

*1、使用类名后面定义的泛型*  ，**所有方法都能用**

*2、在方法申明定义自己的泛型*  ，**只有本方法能用**

**定义格式： 修饰符<类型>返回值类型  方法名(类型  变量名){**



**}**

public <T >  void show( T t){

}

**此处T可以理解为变量，但是不是用来记录数据的，而是记录类型的。**

```
package a04mygenerics;

import java.util.ArrayList;

public class Listutil{
    private Listutil(){

    }
    //类中定义一个静态方法addAll,用来添加多个集合的元素
    /*
       参数一：集合；
       参数二：最后要添加的元素

     */
    public static <E> void addAll(ArrayList<E> list,E e1,E e2,E e3,E e4, E e5){
         list.add(e1);
         list.add(e2);
         list.add(e3);
         list.add(e4);
         list.add(e5);
    }
   /* public static <E> void addAll(ArrayList<E> list,E...e){
        for (E element : e) {
            
        }
    }
    
    */
    public void show(){
        System.out.println("苏苏");
    }
}
```

```
package a04mygenerics;

import java.lang.reflect.Array;
import java.util.ArrayList;

/*
定义一个工具类,Listutil,类中定义一个静态方法addALL,用来添加多个集合元素
 */
public class Generiesdemo3 {
    public static void main(String[] args) {

        ArrayList<String> list=new ArrayList<>();
        Listutil.addAll(list, e1:"aaa",e2:"bbb",e3:"ccc",e4:"ddd",e5:"ddd");

        System.out.println(list);

        ArrayList<Integer> list2=new ArrayList<>();
        Listutil.addAll(list2,e1,e2,e3,e4);
        System.out.println(list2);
    }
}
```

### 泛型接口：

**格式：修饰符  interface  接口名<类型>{**

**}**

*1.实现类给出具体的类型*

*2.实现类延续泛型，创建对象时再确定*

#### 泛型的继承和通配符

**泛型不具备继承性，但是数据具备继承性**

*统一数据类型*

*把运行期间的问题提前到了编译期间，避免了强制。*

*类型转换可能出现的异常，因为在编译阶段类型就能确定下来。*