#  python基础

**python是一个动态类型语言。**
**变量的类型可以随时变化**。
注：布尔值为计算机中的一个位
Python 定义变量 **不需要任何括号**，直接赋值就行：

~~~python
name = "小明"  # 正确：定义一个字符串变量
age = 18      # 正确：定义一个整数变量
~~~



## ipo编码方法

输出——>处理——>输出

## print（输出）

print是py里面的打印（输出）

~~~python
print（value,...,sep=''，end='\n',sile=nome）#end默认为\n
~~~

用法：print（里面为要输出的值）#字符串用单引号括起来，变量用逗号隔开。

## print的参数

### end(指定打印结束时的结尾字符)

默认是\n

 ~~~python
 print("hollo",end='')
 print("world")#不换行
 print("hollo",end='\n)
 print("world")#换行
 print("hollo",end="~~~")
 print("wpeld")#用~~~来分割字段
 print("ww",end='\t')
 print("www")#分隔符
 ~~~

<u>注：\（斜杠）用于转译普通的字符与特殊意义的字符（普通字符<=>特殊字符）</u>

### sep(用于多个输出值之间的分割符)

默认是空格" "
~~~python
print("hollo","worklo",sep="-")
~~~

### file(指定输出目标文件与流)

默认是sys.stdout
~~~python
with open("文件.txt","w") as f:
peint("文字"，file=f)
~~~

### flush（布尔值，控制是否立刻刷新缓冲区）

默认为：false(关闭)
~~~python
import time
for i in range(5):
    print(i,end="",flush=true)#打开刷新
    time.sleep(1)#暂停程序的执行一段时间
~~~

输出值：01234
刷新五次，每次加载都要刷新

| 功能           | 常用方法          | 典型应用场景             |
| :------------- | :---------------- | :----------------------- |
| **获取时间戳** | `time.time()`     | 计算代码运行耗时         |
| **格式化时间** | `time.strftime()` | 生成人类可读的时间字符串 |
| **程序暂停**   | `time.sleep()`    | 控制爬虫请求频率         |

##### time.sleep(实现延迟作用)

为time中的模块函数

~~~python
time.sleep(seconds)#seconds是一个非负浮点数，单位秒
~~~

**用于阻塞调用**：暂停当前线段执行，直到指定的时间结束
**用于多线程工作**：用于暂停当前线程，而不影响其他的线程的执行
**用于浮点数支持**：它支持浮点数作为参考



### objects(可变参数，可以接受任何值作为输出内容)

要打印的类容

## chr（转字符）

chr是内嵌函数#将Ascll和unicode编码转换成字符

~~~python
print（chr（65））
~~~

print（chr（65））='A'（Ascll）
print（chr（ox4e2d）='中'（unicode）

## fp（文件指针与浮点运算）

1.文件指针
标记文件现在的位置，确保操作按顺序进行（把这个东西当成书签）

2.浮点运算
处理带小数的高精度运算（比如算钱与算体重时常见）

~~~python
fp=open("we.txt","w")#定位文件
fp.write("holl")#输入
fp.close()#关闭
~~~

结果：创建一个txt文件，文件中是一个holl（字符）

## type(查看数字类型)

~~~python
my_name='杨'
print('my_name的数字类型是什么：',type(my_name))
~~~

导出是：my_name的数字类型是什么： <class 'float'>

## def（定义函数，有点像HTML的css）

用来创建一个组反复用的：
~~~python
def add(a, b):
    result = a + b
    return result#定义了add这个值

sum = add(1, 7)#带入这个定义
print(sum)
~~~

### import(嵌入函模块与库的关键字的函数)

| **模块**      | **用途**        | **示例用法**                    |
| :------------ | :-------------- | :------------------------------ |
| `math`        | 数学运算        | `math.sqrt(16)` → 4.0           |
| `os`          | 操作系统交互    | `os.listdir()` → 文件列表       |
| `sys`         | 系统参数操作    | `sys.argv` → 命令行参数         |
| `datetime`    | 日期时间处理    | `datetime.now()` → 当前时间     |
| `json`        | JSON 数据编解码 | `json.loads('{"name":"John"}')` |
| `re`          | 正则表达式      | `re.search(r'\d+', 'abc123')`   |
| `random`      | 随机数生成      | `random.randint(1, 100)`        |
| `collections` | 高级数据结构    | `Counter(['a','b','a'])`        |



impont

### 拷贝

**直接赋值（非拷贝）**行为：仅创建对象的新引用，与原对象共享内存

~~~python
a = [1, [2, 3]]
b = a  # 直接赋值
b[0] = 10
print(a)  # [10, [2, 3]]（原对象被修改）
~~~

**浅拷贝（Shallow Copy）**行为：复制对象的顶层结构，但嵌套对象仍为原对象的引用。

~~~python
import copy
a = [1, [2, 3]]
b = copy.copy(a)
b[0] = 10       # 修改顶层元素（不影响原对象）
b[1].append(4)  # 修改嵌套对象（影响原对象）
print(a)        # [1, [2, 3, 4]]
~~~

**深拷贝（Deep Copy）**

~~~python
import copy
a = [1, [2, 3]]
b = copy.deepcopy(a)
b[0] = 10       # 修改顶层元素（不影响原对象）
b[1].append(4)  # 修改嵌套对象（不影响原对象）
print(a)        # [1, [2, 3]]
~~~

| **特性**     | **直接赋值** | **浅拷贝** | **深拷贝**             |
| :----------- | :----------- | :--------- | :--------------------- |
| **顶层对象** | 共享         | 独立       | 独立                   |
| **嵌套对象** | 共享         | 共享       | 独立                   |
| **内存占用** | 低           | 中等       | 高（递归复制所有层级） |
| **性能**     | 最快         | 较快       | 较慢（尤其对复杂结构） |

## 元组（）

**不可变有序序列**数据结构，定义之后不可编辑的，可以包含：整数，字符串，浮点数等可以存储多种元素。

它的访问是：

~~~python
e=(1,20,2)#建立一个元组
print([1])#py计数是从0开始的所以，输出:20
print([-1])#py负索引从末尾计数，输出：2（这个是正常计数）
~~~



| 特性         | 说明                                         | 示例                           |
| :----------- | :------------------------------------------- | :----------------------------- |
| **不可变性** | 创建后不能增删改元素（但元素本身可变如列表） | `t = (1, [2])` 中 `[2]` 可修改 |
| **有序性**   | 元素按插入顺序存储，支持索引和切片           | `t[0]` 获取第一个元素          |
| **异构数据** | 可存储不同类型数据                           | `(1, "a", 3.14)`               |
| **内存效率** | 比列表更节省内存（适合存储常量数据）         |                                |

~~~python
# 标准创建
t1 = (1, 2, 3)          # 显式创建
t2 = 1, 2, 3            # 隐式创建（逗号是关键）
t3 = tuple([1, 2, 3])   # 从列表转换

# 单元素元组（必须加逗号）
single = ("hello",)      # 正确 → 元组,比如（0）为0
#而（0，）是元组（0）
not_tuple = ("hello")    # 错误 → 字符串

# 空元组
empty = ()
~~~

#### 元组（）  	 vs	列表【】

| 特性         | 元组（tuple）               | 列表（list）         |
| :----------- | :-------------------------- | :------------------- |
| **可变性**   | ❌ 不可变                    | ✅ 可变               |
| **语法**     | 圆括号 `()`                 | 方括号 `[]`          |
| **性能**     | 创建和访问更快（约快1.2倍） | 增删操作更高效       |
| **适用场景** | 存储常量数据（如配置项）    | 动态数据集合         |
| **内存占用** | 更小（无超额分配）          | 更大（预留扩展空间） |

## {}	与	【】

空字典:用来存储键值对（就像一本通讯录，名字对应电话）
~~~python
a={}#创建一个字典
print(type(a))# 输出：<class 'dict'>
~~~

空集合：用来存储唯一，不重复的元素（像数学里的集合）

~~~python
empty_set = set()  # 注意！空集合必须这样写，因为 {} 默认是字典！
print(type(empty_set))  # 输出：<class 'set'>
~~~

**如何区分 `{}` 是字典还是集合？**

|             |        |                      |                       |
| :--: | :--: | :--- | :--- |
|                 语法                  |  类型  | 特点                 | 示例                  |
|                 `{}`                  |  字典  | 必须有键值对         | `{"a": 1, "b": 2}`    |
|              `{1, 2, 3}`              |  集合  | 只有值，且不重复     | `{"apple", "banana"}` |
|                set（）                | 空字符 | 唯一创建空集合的方式 | set（） |

~~~python
x = {}          # 这是字典！
y = {1, 2, 3}   # 这是集合！
z = set()       # 这才是真正的空集合！
~~~

- `{}` **默认是空字典**，不是用来定义普通变量的！
- 空集合必须用 `set()`，否则 Python 会以为你要建字典。
- 字典装 **键值对**，集合装 **唯一值**，别搞混啦！

下次看到 `{}`，记得先问自己：**“这是字典还是集合？”**

## 列表[]	 vs  	集合{}

| 特性         | 列表（List）               | 集合（Set）                      |
| :----------- | :------------------------- | :------------------------------- |
| **符号**     | 用方括号 `[]`              | 用花括号 `{}`                    |
| **元素顺序** | 有序（按插入顺序存储）     | 无序（可能每次打印顺序不同）     |
| **重复元素** | 允许重复（比如两个 `"🐶"`） | **自动去重**（只保留一个 `"🐶"`） |
| **功能**     | 可索引、可切片、可修改     | 主要用于快速查找和去重           |

~~~python
a = ["🐱", "🐶", "🦊", "🐶", "🐻"]  # 这是列表！
print(type(a))  # 输出：<class 'list'>
~~~

~~~python
a_set=set(a)
print(a_set) # 输出可能是：{'🐶', '🐱', '🐻', '🦊'}（顺序随机）
#{}中可以包含元组（）不可以包含集合[]
~~~

### **什么时候该用集合？**

- **场景1**：快速判断元素是否存在（比列表快得多！）

  ```python
  if "🐶" in animals_set:  # 集合的查找是O(1)速度！
      print("找到狗子了！")
  ```

- **场景2**：自动去重

  ```python
  dup_list = [1, 2, 2, 3]
  unique_nums = set(dup_list)  # 变成 {1, 2, 3}
  ```

  **方括号 `[]**：像排队买奶茶的队伍，可以有人插队，也可能有人买两杯（重复）！

  **花括号 `{}**：像数学课上的点名册，每个人只能签到一次（去重），但老师可能不按顺序点名（无序）！

### 在py里面允许多个变量同时指向同一个值

~~~python
no=mn=1024#no与mn都是指向1024这个证书值
print(no，mn)
print(id(no))
print(id(mn))
~~~

输出值： 1024 1024
		3028417885104
		3028417885104
都是同一个Id所以为同项

### 总结：变量与常量

![屏幕截图 2025-05-16 185644](py图片/屏幕截图 2025-05-16 185644-1747820008262-41.png)

~~~python
PI=3.1415926#定义一个常量
Pi=3.1415926#定义一个变量
~~~

# **数据类型**

![屏幕截图 2025-05-16 190547](py图片/屏幕截图 2025-05-16 190547-1747820008262-42.png)

~~~python
nu=11
nu1=0b010101010#二进制
nu2=0o765555#八进制
nu3=0xabcdef#16进制
~~~

![屏幕截图 2025-05-16 202006](py图片/屏幕截图 2025-05-16 202006-1747820008262-43.png)

~~~python
gwj=11
print('gwj的数据类型：'，type(gwj))
print(round(0.1+0.2,1))
#注：round函数是四舍五入
print('实数部分：'，x.real)
~~~

![屏幕截图 2025-05-16 202006](py图片/屏幕截图 2025-05-16 214613-1747820008262-44.png)

#### 注：字符串类型，整数类型与浮点数类型都是不可变的数据类型

~~~~python
print(r\R"bj\nbj\nbj\nbj\nbj")
#引号前面加入R或r，所有字符串都变成原码
~~~~



~~~python
ff="""
dddd,
ddddd,
ddddd
"""
~~~

![屏幕截图 2025-05-16 220957](py图片/屏幕截图 2025-05-16 220957-1747820008262-45.png)

~~~python
e="asdfgh"
print(e[1],s[4])#用[]中输入数值来填写，用以上的方法保存
print(e[1,4])
#不可以超出，会报错，‘string index out of range’
~~~

###  **切片(变量【start，stop，step】)**

start ：切片开始的位置（包含）。如果省略，则默认从序列的开头开始。

 stop ：切片结束的位置（不包含）。如果省略，则默认到序列的结尾。

 step ：步长，即每次跳过的元素数量。如果省略，则默认为1（即连续选取元素）。

~~~python
e='holl,python'
print(e[1:4:0])#正常来说是这样的
print(e[:4:])#一样的
~~~



### ![屏幕截图 2025-05-17 131345](py图片/屏幕截图 2025-05-17 131345-1747820008262-46.png)

![屏幕截图 2025-05-17 131434](py图片/屏幕截图 2025-05-17 131434-1747820008262-47.png)

**True为0,第一个字符要大写,bool是布尔值的，布尔值为判断数值**

~~~python
x=True
print(x)
print(type(x))
print(x+10)#True为1——>1+10=11
print(False+10)#False为0——>0+10=10
print(bool(18))#测试18的布尔值
print(bool(0),bool(0.0))#值为False，空字符串的布尔值也是False
#总结：非0的整数布尔值都是True
~~~

![屏幕截图 2025-05-17 133551](py图片/屏幕截图 2025-05-17 133551-1747820008262-48.png)

~~~~python
print(int(3.3))#会转换为3
#注：print('18a')这个会报错，因为a不是十进制数
#注：print('3.14')这个也会报错，因为'3.14'它觉得这个是个数组，它本身也不是一个整数，所以无法转换。
print(float(13))#会转换为13.0
#ord()与chr()是一对
print(ord('杨'))#杨在univode表中对应的整数值
print((chr(26472)))#26472在univode表中字符是什么 
~~~~

## eval（用于去除字符串外侧的引号，并按照py语句方式执行去掉引号后的字符串）

**cval()函数与inp()一起使用**

~~~python
s='3.14+5'
print(s,type(s))#3.14+5 <class 'str'>
x=eval(s)
print(x,type(x))#8.14 <class 'float'>
~~~

## input(用户交互函数)

**返回值为字符串（即便用户输入的数字），所以要手动进行类型转换，用户可能输入的字符不准确(如输入非字符串字符当需要数字时)，需要其他的程序去给他增加程序的逻辑值**
**处理大数据或高性能的应用程序可能会频繁使用input，可能会崩或者影响性能**

~~~python
ega=eval(input('输入你的年龄：'))#input不管怎么输出都是“字符串”，用eval给他转字符为数字
e='北京欢迎你'
print(e)#会输出北京欢迎你
print(eval('e'))#到这个时候就变成了eval去除了e的引号所以e变成了变量
~~~

## 算数运算符

![屏幕截图 2025-05-17 162209](py图片/屏幕截图 2025-05-17 162209-1747820008262-49.png)

![屏幕截图 2025-05-17 163012](py图片/屏幕截图 2025-05-17 163012-1747820008262-50.png)![屏幕截图 2025-05-17 162236](py图片/屏幕截图 2025-05-17 162236-1747820008262-51.png)

~~~python
print('-'*40)#可以乘以字符串
~~~

### 逻辑运算符

![屏幕截图 2025-05-17 163252](py图片/屏幕截图 2025-05-17 163252-1747820008262-52.png)

~~~~python
print(8<0and10/0)#false,10/0并没有计算，因为没有计算所以直接输出第一个数值
~~~~

![屏幕截图 2025-05-17 164905](py图片/屏幕截图 2025-05-17 164905-1747820008262-53.png)

~~~~python
print('按位与运算：'，12&8)#4
print('按位或运算：'，4|8)#12
#把数值转换成二进制运算
~~~~

![屏幕截图 2025-05-17 165745](py图片/屏幕截图 2025-05-17 165745-1747820008263-54.png)

![屏幕截图 2025-05-17 170145](py图片/屏幕截图 2025-05-17 170145-1747820008263-55.png)

```python
num=eval(input('请插入一个四位整数'))
print('个位的状态：',num%10)
print('十位的状态：',num//10%10)
print('百位的状态：',num//100%10)
print('千位的状态：',num//1000%10)
#算数  
```

# 程序组织结构

![屏幕截图 2025-05-18 155702](py图片/屏幕截图 2025-05-18 155702-1747820008263-56.png)

## if（逻辑判断和分支控制）

~~~python
e=10
if e>5:
 print('这个可以')
if e<=5:
 print('这个不可以')
~~~

~~~python
e1=int(input('请输入取款金额 '))
e=1000+e1#要分段计算
if e>=e1:
    print('取款成功')
elif e<e1:
    print('余额不足')
#上面两组都是比较赋值，而第二个的比较赋值更
~~~

~~~~python
s=int(input('请输入数字'))#记得用int赋值不然input输出是字符串
if s%2:
    print(s,'是奇数')
if not s%2:
    print(s,'是偶数')
#看是不是空值
~~~~

~~~python
x=input('数字')
if x:
    print('x为非空值zfc ')
if not x:
    print('x为空值')
#单纯的布尔变量...
~~~

使用if语句时，如果语句块中只有一句代码，可以将语句块直接写在：后面
<u>**else放在最后要所有选项</u>**

### if执行命令

~~~python
e=eval(input('输入'))#构架一个输入取值
if e<0 or e>100#第一变量(看看有没有范围，如果有要把范围定好)
print('不同的输出值')
elif 0<e<60#第二变量
print('不同的输出值')
elif 60<=e<70#看清楚变量的性质与类容
print('不同的输出值')
elif 70<=e<80
print('不同的输出值')
else #最后可以不要因为最后要所有选项
print('不同的输出值')
~~~

![屏幕截图 2025-05-20 221258](py图片/屏幕截图 2025-05-20 221258-1747820008263-57.png)

~~~python
e=eval(input('请问你喝酒了吗'))
if e='y'#e的值为y为喝酒
paoof=eval(input('请输入酒精含量：'))
if paoof<20
print('不构成酒驾')
elif paoof<80#20<paoof<80
print('已经喝酒，不要开车')
elif 
print('已经醉酒')
else：
print('你走吧，没有你的事情')
~~~

### 选择结构

![屏幕截图 2025-05-21 133806](py图片/屏幕截图 2025-05-21 133806-1747820008263-58.png)

~~~python
s=input('名字')
w=input('密码')
if s=='我是' and w=='111111':#并排条件，必须同时通过才可以正确
    print('正确')
else:
    print('不正确')
~~~

![屏幕截图 2025-05-21 164927](py图片/屏幕截图 2025-05-21 164927-1747820008263-59.png)

~~~python
e=int(input('数字'))
if e>0 or e<80:#完成其中一项就可以
    print('正确')
else:
    print('不正确')
~~~

### 循环系统

![屏幕截图 2025-05-21 170558](py图片/屏幕截图 2025-05-21 170558-1747820008263-60.png)

~~~python
e=input('请输入颜色')#模式匹配(用与搜索.替换.y)
match e:
    case 'red':
        print('红色')
    case 'yellow':
        print('黄色')
    case 'blue':
        print('蓝色')
    case _:
        print('未知颜色')#这个并不算循环，
~~~

#### matvh()用来替代if函数

**解构数据（像拆快递一样拆数据）**

~~~python
def 检查坐标(点):
    match 点:
        case (0, 0):
            print("原点！宇宙的起点！")
        case (x, 0):
            print(f"在X轴上，坐标是{x}")
        case (0, y):
            print(f"在Y轴上，海拔{y}米")
        case (x, y):
            print(f"普通坐标：X={x}, Y={y}")
        case _:
            print("这不是个二维坐标！")

检查坐标((3, 0))  # 输出：在X轴上，坐标是3
~~~

**与传统写法对比**

| 场景         | 传统写法                     | `match`写法    | 优势             |
| :----------- | :--------------------------- | :------------- | :--------------- |
| 多条件分支   | 冗长的`if-elif`链            | 结构化模式匹配 | 更直观，更易维护 |
| 数据解构     | 手动`isinstance()`+拆包      | 直接模式匹配   | 减少样板代码     |
| 对象属性检查 | 一堆`hasattr()`和`getattr()` | 类模式匹配     | 代码更声明式     |

# 字符串

在py中，字符串是由引号包裹 的任意字符组成的**不可变序列**，用于表示文本类型数据。
使用单引号或双引号与多引号来定义，用于表示文本信息等等

~~~python
s1= 'select * from user where name = "tom"' 
#小知识：如果在py中用了引号中的任意一种之后还想把一些东西来变成字符串可以用不同的引号
~~~

## 字符串操作

注意：所有的字符串操作，都不会影响原字符串本身，每次操作后都会得到一个操作后的新字符。

### 统计查找替换类

#### len(用来获得参数字符串的字符个数)

该函数并不是字符串类型特有的，而是一个通用函数

~~~python
length = len('holl')
print(length)#输出是4
l = len('holl world')
print(l)#输出是10
~~~

#### count(统计函数)

主要用于统计某个元素在序列（如字符串、列表、元组等）中出现的次数
start或者end指定且返回指定范围内str出现的次数,格式:count(sub，start，end)

- `sub`：要统计的子字符串。
- `start`（可选）：搜索的起始位置。
- `end`（可选）：搜索的结束位置。

~~~python
s = 'hello world'
print(s.count('o'))#公共函数可以直接使用，但是如果前面有变量就在后面加.
#o在'hello world'中有两个，所以这个公式的输出值是2
print(s.count('llo,10,50'))#10为从第10行开始找，50为到50行结束
~~~

注意事项：**1**.count是区分大小写的
		2.元素必须完全匹配：对于列表/元组，`count` 会严格匹配元素值
		3.复杂度：`count` 需要遍历整个序列，时间复杂度为 O(n)。

#### index(是py里面的侦探，查找函数)

比如我们想找一个，格式：index(value，start，end)，value

~~~python
a = ["🐱", "🐶", "🦊", "🐶", "🐻"]#建一个列表
pos = a.index('🦊')#找狐狸的位置
print(f"狐狸的位置是{pos}")#这个地方的输出是2，因为🐱为0以此类推
#在字符串中用{}带入数值这个是f-string，记得在引号前面加个f。
print(a.index("🐶",2))#缩小范围，
~~~

特点：
1.精准定位：告诉你想要的值的第一次出现的位置（如果你没有加条件的话，它只告诉你第一个的位置）
2.所以就可以用这样的“print(a.index("🐶",2))”用例来缩小范围
3.抓不到就报错：用valueerror报错
4. 如果它罢工了，记得检查你要找的东西是不是真的在列表里哦！

### **count vs index**

- `count`：像个会计，**数数**某个值出现多少次。
- `index`：像个侦探，**找位置**，但只报告第一次的发现！
- rindex:也是找位置，只不过从右侧开始寻找。

~~~python
lst = ["A", "B", "A", "C"]
print(lst.count("A"))  # 输出：2（会计数出2个A）
print(lst.index("A"))  # 输出：0（侦探只报告第一个A的位置）
print(lst.rindex("A"))  #输出：0（它从右侧找从左侧数）#要记这个
~~~

### 条件案例

找到小心在什么地方上课？

~~~pyhton
o = ['小梅'，'小心','威威','好好']
print(o.index('小心'))
~~~

找小红，没有小红说“小红逃课了”

~~~~python
if '小红' in o:
	print(f"小红在{o.index('小红')}位置")
else:
	print(f"小红翘课")
~~~~

### find(与index一样是查找字符函数)

与index一样是查找字符串的函数，找到了返回第一个出现的索引；没有找到且返回-1（它不像index一样直接报错），它只可以找字符串
语法：字符串.find(子字符串, [开始索引, [结束索引]])

rfind是 如rindex一样的从右侧开始查找，从左侧开始数

~~~python
lst = ['文档大道顶顶顶']#加了[]为列表
s= lst[0]#转换为字符串
print(type(lst))#输出为<class 'list'>
print(type(s))#输出为<class 'str'>
print(s.index("顶"))  # 输出：4
print(s.find("顶"))  # 输出：4
print(s.find("77"))#输出：-1
~~~

查找所有匹配（循环）

```python
s = "hello world, hello python,hello sj"
target = "hello"
start = 0
while True:#开启一个循环
    pos = s.find(target, start)
    if pos == -1:  # 找不到了
        break#找不到就跳出循环
    print(f"找到 '{target}' 在位置 {pos}")
    start = pos + 1  # 继续往后找
```

注意

- **检查子串是否存在**（比 `in` 更精确，能知道位置）
- **安全查找**（不想让程序因找不到而崩溃时）
- **多次查找**（结合循环找所有匹配）
- **区分大小写**（"Hello".find('h'）输出：-1）
- **仅限字符串**:列表、元组不可以用find（），要用index（）
- **返回第一个匹配**：如果找所有匹配需要用循环（如上列）

### replace(替换函数)

**把字符串中的 旧内容替换成新内容，而且还能控制替换的次数,源字符串不会发生变化！**

语法：新字符串 = 原字符串.replace(旧内容, 新内容, [替换次数])

~~~python
s='喵喵喵喵'
e= s.replace('喵','汪')#替换无效
print(e)#它默认替换所有匹配值，输出：汪汪汪汪
r= s.replace('喵','汪'，2)#输出：汪汪喵喵
q= s.replace('喵','')#输出：空值，就是把他删除了
~~~

- 三大特点：
  1️⃣ 简单直接的固定文本替换
  2️⃣ 可控制替换次数
  3️⃣ 永远返回新字符串（原字符串不变）

限制：**不支持正则表达式**（复杂替换要用 `re.sub()`）

## 字符串判断类

### startwith（判断指定的前缀开头函数）

**判断指定的前缀开头，返回 `True` 或 `False`它还能指定检查的起始和结束位置。**
语法：字符串.startswith(前缀, [开始索引, [结束索引]])

~~~python
s = "hello world"
print(s.startswith("hello"))  # 输出：True
print(s.startswith("world"))  # 输出：False
print(s.startswith("world",6))# 输出：True
print(s.startswith(['h'])) #输出：TypeError
#前缀可以是字符串或元组，但不能是列表（会报错）

~~~

**与 `in` 的区别**

| 方法           | 作用                     | 返回值 | 典型用途             |
| :------------- | :----------------------- | :----- | :------------------- |
| `startswith()` | 检查**开头是否匹配**     | bool   | 验证前缀、文件分类   |
| `in`           | 检查**任意位置是否包含** | bool   | 模糊搜索、关键词检测 |

~~~python
s = "python编程"
print(s.startswith("py"))    # True（开头匹配）
print("py" in s)             # True（任意位置）
~~~



- `startswith()` 是 **前缀检查专家**
  对长字符串建议指定检查范围，减少不必要的扫描
  就是这个不区分大小写 
- 三大优势：
  1️⃣ 支持**多前缀检查**（传入元组）
  2️⃣ 可**限定检查范围**
  3️⃣ **比 `in` 更精准**（只检查开头）
- 经典应用场景：文件分类、URL验证、数据清洗

### endswith(判断字符串是否以指定字符串结束)

~~~python
#其实它与startwith一样的，方法也与它差不多，就是一个前一个后
e= 'ssss.exe'
if e.startswith(('ssss')) and e.endswith(('.exe'))
	print('合法')
else:
    print('不合法的')
~~~

#### 字符串判断类

这6个都是查找字符,有就返回True，没有返回false

isalpha(查字符，所有都是字符或者字母的，不可以有数字)
isdigit（查数字，所有都是数字，不可以有字符串）
isalnum(至少有一个字符并且所有的字符都是字母或数字)
isspace(只包括空格:"  " ,按tab键,\r,\n,\t,都算空白字符)
isupper(判断字符串是不是全都是大写的字母)
islower(判断是否是小写的字母)
istitle(判断所有字符是不是标题化的（所有单词首字母是大写的）)

#### 字符串转换类

与类似方法的比较，格式：源字符串 

| 方法           | 功能                   | 示例                          |
| :------------- | :--------------------- | :---------------------------- |
| `capitalize()` | 仅首字母大写，其余小写 | "pyThon" → "Python"           |
| `title()`      | 每个单词首字母大写     | "hello world" → "Hello World" |
| `upper()`      | 所有字母大写           | "python" → "PYTHON"           |
| `lower()`      | 所有字母小写           | "PyThon" → "python"           |

#### 字符串对齐类

| 方法           | 作用     | 示例（原字符串："hi"） | 输出（宽度=5）                                  |
| :------------- | :------- | :--------------------- | :---------------------------------------------- |
| **`center()`** | 居中对齐 | `"hi".center(5, "-")`  | `"--h--"` ❌ → 修正示例应为 `"-hi--"`（总宽度5） |
| **`ljust()`**  | 左对齐   | `"hi".ljust(5, "-")`   | `"hi---"`                                       |
| **`rjust()`**  | 右对齐   | `"hi".rjust(5, "-")`   | `"---hi"`                                       |

#### 字符串去除空白类

语法：新字符串 = 原字符串.strip([chars])

- **chars**（可选）：要去除的字符集合（字符串形式），默认去除空白符（空格、`\t`、`\n`等）

| 方法       | 作用               | 示例                                |      |
| :--------- | :----------------- | :---------------------------------- | ---- |
| `lstrip()` | 只去除**左侧**字符 | `" hi ".lstrip()` → `"hi "`         |      |
| `rstrip()` | 只去除**右侧**字符 | `"hello!!".rstrip("!")` → `"hello"` |      |
| strip()    | 去除**首尾**字符   | "!holl!!".strip('!')-->"holl"       |      |

#### 字符串分割类

把字符串变为列表 

| 方法              | 分隔符类型  | 方向 | 返回类型 | 典型场景          |
| :---------------- | :---------- | :--- | :------- | :---------------- |
| `split()`         | 单字符/空白 | 从左 | 列表     | 通用数据分割      |
| `rsplit()`        | 单字符      | 从右 | 列表     | 提取文件扩展名    |
| `splitlines()`    | 行符        | -    | 列表     | 多行文本处理      |
| `partition()`     | 单字符      | 从左 | 三元组   | 快速键值提取      |
| `re.split()`      | 正则表达式  | -    | 列表     | 复杂分隔符处理    |
| `textwrap.wrap()` | 固定宽度    | -    | 列表     | 文本排版/短信分段 |

#### 字符串连接类

列表或者其他

| 方法/操作符        | 最佳场景                   | 特点                       | 示例                               | 效率 |
| :----------------- | :------------------------- | :------------------------- | :--------------------------------- | :--- |
| **1. `+` 操作符**  | 少量固定字符串拼接         | 代码直观，但每次创建新对象 | `"Hello" + " " + "World"`          | ⭐    |
| **2. `join()`**    | 连接列表/元组中的字符串    | 高性能，可指定连接符       | `" ".join(["A", "B", "C"])`        | ⭐⭐⭐⭐ |
| **3. f-string**    | 含变量/表达式的字符串生成  | 可读性强，Python 3.6+特性  | `f"{name} is {age} years old"`     | ⭐⭐⭐⭐ |
| **4. `format()`**  | 兼容新旧Python版本的格式化 | 支持位置/关键字参数        | `"{}".format("value")`             | ⭐⭐⭐  |
| **5. `%` 格式化**  | 旧版代码维护               | 类似C语言的语法            | `"%s %d" % ("A", 1)`               | ⭐⭐   |
| **6. `\*` 操作符** | 生成重复模式字符串         | 快速创建规律文本           | `"-" * 20`                         | ⭐⭐⭐⭐ |
| **7. `StringIO`**  | 海量字符串拼接（10万+次）  | 内存友好，适合日志构建     | `StringIO().write("A").getvalue()` | ⭐⭐⭐⭐ |

#### 编码解码类

在字符串与二进制数据转换

**(1) 编码：`str.encode()`**

~~~python
rt="python编辑"
r= rt.encode("utf-8")
print(r) #输出：b'python\xe7\xbc\x96\xe8\xbe\x91'
~~~

**(2) 解码：`bytes.decode()`**

~~~python
r1 = decode("utf-8")#输出：python编辑
~~~

| 编码        | 描述                    | 适用场景                 |
| :---------- | :---------------------- | :----------------------- |
| **UTF-8**   | 兼容ASCII，支持全球语言 | 网络传输、跨平台文件存储 |
| **GBK**     | 中文编码                | 处理中文Windows系统文件  |
| **ASCII**   | 仅支持英文和符号        | 旧系统兼容               |
| **Unicode** | 内存中的统一编码        | Python内部字符串表示     |

解决乱码问题

~~~python
def safe_decode(data):#尝试不同编码解码
    for encoding in ["utf-8", "gbk", "latin1"]:#创建3个编码的列表循环
        try:
            return data.decode(encoding)
        except UnicodeDecodeError:#如遇UnicodeDecodeError异常，捕捉异常继续输出下一个解码字符。
            continue
    return data.decode("utf-8", errors="replace")#如果没有找到，最后解码为utf-8
~~~

## 循环

循环：提高代码复用率，减少代冗余

#### for...in...（重复一定时间的循环）

重复一定次数的循环

~~~python
name = ['ddd','bbb','aas'] 
for i in name:
    print(name)#默认3串['ddd', 'bbb', 'aas']
~~~

#### while(条件循环)

只要条件为真，循环就一直重复，直到不满足为之

~~~py
#模板
def u():
    d=1#构成循环结束条件，给予循环定义要素变量1
    while d <= 100:
        print('hogwarts--',d)
        d += 1

if __name__ == '__main__':#程序入口
    u()
~~~

~~~python
#列1
#求所有1~10的所有整数的积
def s():
    d = 1
    result = 1#定义两个变量
    while d<=10:#循环10次
    	ressult *= d#乘于
    	print(result)
    	d += 1
    print("R:",result)

if __name__ == '__main__':
    s()
~~~

~~~python
def loop3():
    n = 1
    while n <= 100:
        if n % 7 == 0 or '7' in str(n):#用if函数去取值
            print(n)
        n += 1

if __name__ == '__main__':
    loop3()
~~~

## 测试，assert

assert 条件, "错误提示信息"  # 中括号部分可选

工作逻辑：

A[执行assert语句] --> B{条件为真?}
B -->|是| C[继续执行]
B -->|否| D[抛出AssertionError]
D --> E[显示错误信息]

~~~python
#列子
def 做蛋糕(面粉, 鸡蛋):
    assert 面粉 > 0, "没面粉做个锤子蛋糕！"  # ← 保镖上线
    assert 鸡蛋 >= 2, "至少需要2个鸡蛋！"   # ← 保镖二次检查
    
    print("🎂 美味蛋糕制作中...")
    return "香喷喷的蛋糕"
~~~

不可以用来生成环境
不可以用来做处理异常的工具

性能：

1. **调试时多用**：开发阶段的"安全网"
2. **生产环境慎用**：关键检查改用正式异常处理
3. **写明确错误信息**：`assert x > 0, "x必须是正数"`
4. **不要改数据状态**：assert应该是"只读"检查
5. **与测试框架配合**：

~~~python
# pytest中可以直接用assert
def test_addition():
    assert 1 + 1 == 2
    assert 2 + 2 == 5, "错了"  # 这会触发测试失败
~~~

